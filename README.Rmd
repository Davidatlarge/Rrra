---
title: "Rrra"
author: "David Kaiser"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
sapply(list.files("functions/", full.names = T), source)
```

## intro
R toolbox for processing of Radium data from RaDeCC.

## read data from RaDeCC output file
`read_ra()` returns a list with all the content of the file. The detector names that should be part of the file name can be supplied as an argument `detectors`. The date format for the Start Time and Stop Time in the file is supplied in strptime-style via `date.format`.

```{r}
Ra <- read_ra(file = "data/test_case1/050621_1grey_St3.txt",
              detectors = c("orange","blue","grey","green"), # these are current default values in the function
              date.format = "%m/%d/%Y") # these are current default values in the function
Ra
```

## get summaries of blank values and detector efficiency 
`summarise_blank()` and `summarise_efficiency()` take a list of file names, call `identify_type()` to identify blanks and standards, respectively, call `read_ra()` to read the results, and return a summary when `summarise = TRUE` (the default), or a table of all values if `summarise = FALSE`. `identify_type()` looks in the file name for strings; current defaults are `blank.id = "blank"` and `standard.id = "standard|std"`.

```{r}
files <- list.files("data/AL557/", recursive = TRUE, full.names = TRUE, pattern = ".txt$")
blk <- summarise_blank(files)
blk
```

A warning will be printed if less than 3 values are used in a summary.

```{r}
eff <- summarise_efficiency(files)
eff
```

`summarise_efficiency()` internally calls `calculate_efficiency()` to calculate efficiency.

```{r}
calculate_efficiency(Ra = read_ra("data/AL557/Standards/050621_1orange_223Rastandard.txt"))
```

## process the results of sample measurements
`process_ra()` takes the output of `read_ra()` and returns values that can be derived solely from the data in one measurement result file.

```{r}
pro <- process_ra(Ra)
t( pro ) # transpose for better readability here
```

`mutate_ra()` takes the output of `summarise_efficiency()`, `summarise_blank()`, `process_ra()`, as well as additional metadata to return more derived values. With the argument `merged.output = TRUE` (the default) the new values will be added to the output of `process_ra()` (which then could be overwritten; or the functions could be nested).

```{r} 
final <- mutate_ra(eff = eff, 
                   blk = blk,
                   pro = pro,
                   filtration_volume_L = 200.5, 
                   merged.output = TRUE)
t( # transpose for better readability here
  final[!(names(final)%in%names(pro))] # show only those columns not in the output of process_ra()
   )
```

# example with a single sample
We use the blank and efficiency values created above. 
And we add two required metadata (will be done differently later). 

```{r}
sampling.time <- as.POSIXct("2021-06-05 09:52:00")
filtration_volume_L <- 200.5
```

Two count measurements of one sample are (generally) needed for a result.
Here we load and process the values "manually" but this will change later.

```{r}
# count 1
c1 <- read_ra("data/test_case1/050621_1grey_St3.txt")
c1 <- process_ra(c1)
c1 <- mutate_ra(eff = eff, blk = blk, pro = c1, filtration_volume_L = filtration_volume_L)

# count 2
c2 <- read_ra("data/test_case1/130621_green_St3_2.txt")
c2 <- process_ra(c2)
c2 <- mutate_ra(eff = eff, blk = blk, pro = c2, filtration_volume_L = filtration_volume_L)
```

To correct for the ingrowth of decaying 228Th we estimate the amount of 228Th on the fiber using `onFiber_228Th` (the name is pretty bad and I'll change that).

```{r}
onFiber228Th <- onFiber_228Th(midpoint.1 = c1$midpoint, 
                              midpoint.2 = c2$midpoint, 
                              dpm.220per100L.1 = c1$dpm.220per100L,
                              dpm.220per100L.2 = c2$dpm.220per100L)
onFiber228Th
```

The results, can then be calculated from the processed values of the first measurement/count using `results_Ra()`.

```{r}
results <- results_Ra(c1, sampling.time, onFiber228Th)
results
```

Relevant metadata can easily be added.

```{r}
results$file <- c1$file
results$sampling.time <- sampling.time
results
```

# example with multiple samples
To avoid the need to run the example workflow above for each sample, `process_samples()` loops over all sample files in a file list.
The function accepts a list of file paths, and internally calls `identify_type()` to see which files are samples, so that also other files, like blanks and standards can be stored in the same folder. 
The file list can thus be the same as that used in `summarise_blank()` and `summarise_efficiency()` (that's not the case in this example, though).
Samples are then read with `read_ra()` and processed with `process_ra()` and `mutate_ra()`, and the output bound into a data frame. This dataframe can be returned by setting the argument `halfway = TRUE`. The target output however is a data frame of the output from `result_ra()` for each sample. 
Therefore, the function identifies samples from the file name using the argument `sample.id.pattern`, which (currently) accepts a regex pattern of the sample name. Measurements with the same sample ID are then processed in groups with `onFiber_228Th()` and `result_ra()`.

In this example we have 2 samples with two measurements/counts each.
(Note: the function also works when only counts of one sample are supplied, and then returns the result of only that sample)

```{r}
samples <- list.files("data/test_case1/", pattern = ".txt$", full.names = TRUE)
samples
```

The samples are named "St2" and "St3". 
So to identify these we use `sample.id.pattern = "St[1-9]{1}"`.

EDIT: the sample ID is now defined as anything including the (last) occurrence of "St" but before the next "_" or before the ".txt" extension. This is case-insensitive.

Examples:  
`050621_2blue_St2.txt` becomes `St2`  
`140621_blue_st5-AlkorCruise_2.txt` becomes `st5-AlkorCruise`  
but  
`140621_blue_st5_AlkorCruise_2.txt` becomes `st5`  
`050621_orange_st1cont.txt` becomes `st1cont`
`050621_st6grey_.txt` becomes `st6grey`


For now, we supply the required metadata, i.e. filtration volume and sampling time, in a data frame that will be passed to the argument `meta`.
The column names must be exact, because `process_samples()` looks for those.

```{r}
meta <- data.frame(id = c("St2", "St3"),
                   sampling.time = as.POSIXct(c("2021-06-05 09:43:00", "2021-06-05 09:52:00")),
                   volume = c(200.4, 200.5))
meta
```

Now we can run the example.

```{r}
process_samples(files = samples,
                blk = blk, eff = eff, meta = meta,
                sample.id.pattern = "St[1-9]{1}", 
                halfway = FALSE)
```


# next
- add necessary arguments to parent functions, e.g. 
  - inherit `detectors` and `date.format` in read_ra() from parents
    - parents: summarise_blank(), summarise_efficiency(), process_samples()
  - pass the standard efficiencies from summarise_efficiency() to internal calculate_efficiency()
  - identify_type() needs to inherit `blank.id` and `standard.id` -> DONE




- data output
  - which meta data should be part of the output of process_samples()?
  - should results_Ra() return the decay factors? (currently it doesn't)
  - should summarise_blank() return values for CPMTot? (currently it does but is not used downstream)
- code clean-up 
  - change function and argument names to something nicer
  - get rid of unnecessary ()
  - remove objects not needed downstream
  - unify the use of . and _ in function and argument names
  - remove comments that are notes for the process (e.g. comparisons with excel)
- error handling

# probably dumb questions
- how come sampling time only comes in at results_ra()?
- why use half life of 224Ra when correcting for 228Th decay ingrowth? e.g. in onFiber_228Th()
- in excel sheet blanks cols P and L seem to link to the wrong cols, no downstream effect though.
- it seems that the standards for efficiency are not blank corrected, but there are standard blanks, is this a problem?