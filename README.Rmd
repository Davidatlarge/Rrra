---
title: "Rrra"
author: "David Kaiser"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
sapply(list.files("functions/", full.names = T), source)
```

## intro
R toolbox for processing of Radium data from RaDeCC.

## Principal workflow
The main function of this toolbox is `process_samples()`. It accepts a list of files that contains the sample but possibly also other measurement files, data frames containing values for measurement blanks, for detector efficiency values and meta data, as well as some additional arguments.

The files for samples, blanks and standards can be located in the same folder/path. 
```{r}
files <- list.files("data/test_case1/", recursive = TRUE, full.names = TRUE, pattern = ".txt$")
```

The meta data is supplied in a simple table. A wrapper for a read function to access excel sheets will follow soon.
```{r}
meta <- data.frame(id = c("St2", "St3", "St5"),
                   sampling.time = as.POSIXct(c("2021-06-05 09:43:00", "2021-06-05 09:52:00", "2021-06-15 09:52:00")),
                   volume = c(200.4, 200.5, 220.5))
meta
```

Also, we can define those arguments used multiple times.
```{r}
detec = c("orange","blue","grey","green")
datef = "%m/%d/%Y"
standard.id = "standard|std"
blank.id = "blank"
```

The function `summarise_blank()` finds, processes and summarises files containing blank measurements. To identify blanks from the file name, it accepts input to the argument `blank.id`, and to properly summarise, it accepts a vector of detector names in `detectors`. A warning will be printed if less than 3 values are used in a summary. 
```{r}
blk <- summarise_blank(files,
                       date.format = datef, 
                       detectors = detec, 
                       blank.id = blank.id, 
                       summarise = TRUE)
head(blk)
```

Similarly, `summarise_efficiency()` finds and works with files containing standard measurements. It additionally takes input for `standard.id`, as well as DPM values for the standards used. 
```{r}
eff <- summarise_efficiency(files,
                            date.format = datef, 
                            detectors = detec,
                            standard.id = standard.id, 
                            blank.id = blank.id,
                            dpm.223.std = 9.94, # Personal Comm Walter Geibert (AWI)
                            dpm.224.std = 12.1, # Personal Comm Walter Geibert (AWI)
                            summarise = TRUE)
head(eff)
```

Finally, `process_samples()` takes the meta data, output from `summarise_blank()` and `summarise_efficiencies()`, as well as the blank and standard identifiers and an estimate for 227Ac. The detector names are extracted from the inputs to `blk` and `eff`. With `verbose = TRUE` comes a stream of information about file processing, printed to the console. Setting `halfway = TRUE` returns a table of all the values for each sample file that are used for the final calculation of results. All these functions also accept the `date.format` to enable the use of files created by different system time settings.  
```{r}
out <- process_samples(files = files,
                       blk = blk, 
                       eff = eff, 
                       meta = meta,
                       date.format = datef, 
                       standard.id = standard.id, 
                       blank.id = blank.id,
                       estimate.227Ac = 0.05,
                       halfway = FALSE, 
                       verbose = TRUE)
out
```



## under the hood
### file handling
`files` (paths to files) can be different for samples, blanks and standards, but can also be the same, i.e. all relevant files can be in one folder

EDIT: the sample ID is now defined as anything including the (last) occurrence of "St" but before the next "_" or before the ".txt" extension. This is case-insensitive.

Examples:  
`050621_2blue_St2.txt` becomes `St2`  
`140621_blue_st5-AlkorCruise_2.txt` becomes `st5-AlkorCruise`  
but  
`140621_blue_st5_AlkorCruise_2.txt` becomes `st5`  
`050621_orange_st1cont.txt` becomes `st1cont`
`050621_st6grey_.txt` becomes `st6grey`

## read data from RaDeCC output file
`read_ra()` returns a list with all the content of the file. The detector names that should be part of the file name can be supplied as an argument `detectors`. The date format for the Start Time and Stop Time in the file is supplied in strptime-style via `date.format`.

```{r}
Ra <- read_ra(file = "data/test_case1/samples/050621_1grey_St3.txt", detectors = detec, date.format = datef) # these are current default values in the function
Ra
```

### process the results of sample measurements
`process_ra()` takes the output of `read_ra()` and returns values that can be derived solely from the data in one measurement result file.

```{r}
pro <- process_ra(Ra)
t( pro ) # transpose for better readability here
```

`mutate_ra()` takes the output of `summarise_efficiency()`, `summarise_blank()`, `process_ra()`, as well as additional metadata to return more derived values. With the argument `merged.output = TRUE` (the default) the new values will be added to the output of `process_ra()` (which then could be overwritten; or the functions could be nested).

```{r} 
final <- mutate_ra(eff = eff, 
                   blk = blk,
                   pro = pro,
                   filtration_volume_L = 200.5, 
                   merged.output = TRUE)
t( # transpose for better readability here
  final[!(names(final)%in%names(pro))] # show only those columns not in the output of process_ra()
   )
```

# example with a single sample
We use the blank and efficiency values created above. 
And we add two required metadata (will be done differently later). 

```{r}
sampling.time <- as.POSIXct("2021-06-05 09:52:00")
filtration_volume_L <- 200.5
```

Two count measurements of one sample are (generally) needed for a result.
Here we load and process the values "manually" but this will change later.

```{r}
# count 1
c1 <- read_ra("data/test_case1/samples/050621_1grey_St3.txt", detectors = detec, date.format = datef)
c1 <- process_ra(c1)
c1 <- mutate_ra(eff = eff, blk = blk, pro = c1, filtration_volume_L = filtration_volume_L)

# count 2
c2 <- read_ra("data/test_case1/samples/130621_green_St3_2.txt", detectors = detec, date.format = datef)
c2 <- process_ra(c2)
c2 <- mutate_ra(eff = eff, blk = blk, pro = c2, filtration_volume_L = filtration_volume_L)
```

To correct for the ingrowth of decaying 228Th we estimate the amount of 228Th on the fiber using `onFiber_228Th` (the name is pretty bad and I'll change that).

```{r}
onFiber228Th <- onFiber_228Th(midpoint.1 = c1$midpoint, 
                              midpoint.2 = c2$midpoint, 
                              dpm.220per100L.1 = c1$dpm.220per100L,
                              dpm.220per100L.2 = c2$dpm.220per100L)
onFiber228Th
```

The results, can then be calculated from the processed values of the first measurement/count using `results_Ra()`.

```{r}
results <- results_Ra(count1 = c1, 
                      sampling.time = sampling.time, 
                      onFiber228Th = onFiber228Th, 
                      estimate.227Ac = 0.05)
results
```

Relevant metadata can easily be added.

```{r}
results$file <- c1$file
results$sampling.time <- sampling.time
results
```


# next
- solve this problem:
  - `identify_type(string = "St223_224standard_20200223", blank.id = "blank", standard.id = "standard|std")`
- data output
  - which meta data should be part of the output of process_samples()?
  - should results_Ra() return the decay factors? (currently it doesn't)
  - should summarise_blank() return values for CPMTot? (currently it does but is not used downstream)
- code clean-up 
  - change function and argument names to something nicer
  - get rid of unnecessary ()
  - remove objects not needed downstream
  - unify the use of . and _ in function and argument names
  - remove comments that are notes for the process (e.g. comparisons with excel)
- error handling

# probably dumb questions
- how come sampling time only comes in at results_ra()?
- why use half life of 224Ra when correcting for 228Th decay ingrowth? e.g. in onFiber_228Th()
- in excel sheet blanks cols P and L seem to link to the wrong cols, no downstream effect though.
- it seems that the standards for efficiency are not blank corrected, but there are standard blanks, is this a problem?